{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "plt.rcParams[\"figure.figsize\"]=[18, 11]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Create empty class of formulas A2.*\n",
    "class formulas_A2:\n",
    "    pass\n",
    "A2=formulas_A2()# Создаем абсолютно пусто Инстанс (экземпляр) 'A2'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Вводим в оборот формулы А2.10 и А2.11\n",
    "def __(self, ai): #(A2.10)\n",
    "    #вводим константы для (A2.10)\n",
    "    self.B= 12.5\n",
    "    self.BN= 0.2*self.B\n",
    "    self.Be= self.B - (self.B-self.BN)**2/self.B # (A2.11)\n",
    "    self.E= 195000.\n",
    "    self.W= 25.\n",
    "    \n",
    "    self.ai=ai #?\n",
    "    ai_w=ai/self.W\n",
    "    return (2.1630 + 12.219*ai_w - 20.065*ai_w**2 - 0.9925*ai_w**3 + 20.609*ai_w**4 - 9.9314*ai_w**5) * \\\n",
    "        ( (self.W+ai)/(self.W-ai) )**2./(self.E*self.Be)\n",
    "    #\n",
    "\n",
    "formulas_A2._10 = __      # добавляем метод в Класс 'formulas_A2'\n",
    "A2._10(0.151550581328749) # Юзаем метод для уже существующего Инстанса(экземпляра) 'A2' (test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Вводим в оборот метод чтения данных и строим интерполяторы\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "def __(self, forcedat, cracklength):\n",
    "    self.force = np.loadtxt(forcedat, dtype=np.float)\n",
    "  #  self.force[:,1]*=2.0\n",
    "  #  self.force[:,2]*=2.0\n",
    "    self.force_interp = interp1d(self.force[:,1],self.force[:,2], bounds_error=False)\n",
    "\n",
    "    #загружаем, редуцируем и модифицируем \"crack-length_calc1.dat\"\n",
    "    crk=[]\n",
    "    for xx in np.loadtxt(cracklength, dtype=np.float):\n",
    "        if xx[1]:\n",
    "            crk.append([xx[1], self._10(xx[1]+15.2)])\n",
    "    self.crack=np.asarray(crk)\n",
    "\n",
    "    #интерполяторы редуцированного массива crack\n",
    "    self.crack_interp = interp1d(self.crack[:,0],self.crack[:,1], bounds_error=False)\n",
    "    self.crack_cmode_interp = interp1d(self.crack[:,0], self.force[:,1][- len(self.crack): ], bounds_error=False)\n",
    "    #\n",
    "formulas_A2.read=__ #добавляем метод в Класс 'formulas_A2'\n",
    "A2.read(\"FORCE_CMOD_U820_V2.dat\",\"crack-length_U820_V2.dat\") # Юзаем метод для уже существующего Инстанса(экземпляра) 'A2'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST\n",
    "# сплошная линия построена по данным массива A2.crack\n",
    "# контрольные точки построены через функцию-интерполятор массива\n",
    "\n",
    "plt.rcParams[\"figure.figsize\"]=[18, 11]\n",
    "plt.plot(A2.crack[:,0],A2.crack[:,1])\n",
    "plt.xlabel('DELTA_A, mm')\n",
    "plt.ylabel('Cc, mm/N    (A2.11)')\n",
    "for _ in [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]:\n",
    "    plt.plot(_, A2.crack_interp(_), 'rx')\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST\n",
    "# сплошная линия построена по данным массива A2.force\n",
    "# контрольные точки построены через функцию-интерполятор массива\n",
    "plt.plot(A2.force[:,1], A2.force[:,2])\n",
    "plt.xlabel('CMOD, mm')\n",
    "plt.ylabel('FORCE, N')\n",
    "\n",
    "for _ in [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75]:\n",
    "    plt.plot(_, A2.force_interp(_), 'rx') # second point\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST\n",
    "plt.plot(A2.crack[:,0], A2.force[:,1][-len(A2.crack) : ])\n",
    "plt.xlabel('DELTA_A, mm')\n",
    "plt.ylabel('CMOD, mm')\n",
    "for _ in [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75]:\n",
    "    plt.plot(_, A2.crack_cmode_interp(_), 'rx') # second point\n",
    "\n",
    "plt.grid()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "from scipy.optimize import fsolve\n",
    "\n",
    "def __(self, delta):\n",
    "    self.delta=delta\n",
    "    cc_ = 1./self.crack_interp(delta).item()\n",
    "    cmode_ = self.crack_cmode_interp(self.delta).item()\n",
    "    self.cc_ = cc_\n",
    "    self.cmode_ = cmode_\n",
    "\n",
    "    x2_ = fsolve(lambda x:A2.force_interp(x) - cc_*(x-cmode_), cmode_)[0]\n",
    "    y2_ = (x2_ - cmode_) * cc_ \n",
    "\n",
    "    print \"cc_ = %r, cmode_= %r x2_= %r\" % (cc_, cmode_, x2_)\n",
    "    \n",
    "    from scipy.integrate import quad\n",
    "    self.apl = quad(self.force_interp, self.force[:,1][0], x2_)[0] - y2_ * (x2_ - cmode_) * 0.5\n",
    "    self.P = y2_\n",
    "\n",
    "    return (cmode_, x2_, y2_)\n",
    "    #\n",
    "formulas_A2.Apl=__  # добавляем метод 'Apl' в class 'formulas_A2'\n",
    "A2.Apl(1.), A2.P, A2.apl # юзаем метод 'Apl' в объекте 'A2' (test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST\n",
    "plt.plot( A2.force[:,1], A2.force_interp(A2.force[:,1]))\n",
    "plt.plot( A2.force[:,1], A2.cc_*(A2.force[:,1]-A2.cmode_))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "sht=pd.read_excel(pd.ExcelFile('1757-A52.xls'),'Channels by Ste')\n",
    "sht.iloc[2:,2].values, sht.iloc[2:,1].values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "sht=pd.read_excel(pd.ExcelFile('1757-A52.xls'),'Channels by Ste')\n",
    "xlsm_ = np.transpose(np.asarray((sht.iloc[2:,2].values,sht.iloc[2:,1].values)))\n",
    "\n",
    "xlsm_,  xlsm_[:,0], xlsm_[:,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "xlsm_[:,0], xlsm_[:,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(A2.force[:,1], A2.force[:,2])\n",
    "A_= A2.Apl(1.0)\n",
    "\n",
    "plt.plot(A_[0], 0.0, 'ro') # first point\n",
    "plt.plot(A_[1], A_[2], 'ro') # second point\n",
    "plt.plot([A_[0],A_[1]], [0.0, A_[2]], 'ro-')\n",
    "\n",
    "plt.plot( xlsm_[:,0], xlsm_[:,1])\n",
    "\"\"\"\n",
    "\"\"\"\n",
    "\n",
    "plt.xlabel('CMOD, mm')\n",
    "plt.ylabel('FORCE, N')\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[18, 11]\n",
    "plt.show()\n",
    "A_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def __(self): #(A2.6)\n",
    "    b_0=self.W-self.delta-15.2\n",
    "    self.jpl= (2.+0.522*b_0/self.W)*self.apl/(self.BN*b_0)\n",
    "    pass\n",
    "    #\n",
    "formulas_A2.Jpl = __   # добавляем метод в class 'formulas_A2'\n",
    "A2.Jpl()               # юзаем метод в объекте 'A2' (test)\n",
    "A2.jpl  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "def __(self):\n",
    "    self.nu = 0.3\n",
    "    ai_w=(self.delta+15.2)/self.W\n",
    "    fi= ((2.0+ai_w)*(0.886 + 4.64*ai_w - 13.32*ai_w**2 + 14.72*ai_w**3 - 5.6*ai_w**4)) * (1-ai_w)**1.5\n",
    "    Ki= (self.P * fi /(self.B*self.BN*self.W))**0.5\n",
    "    self.jel= Ki*Ki*(1-self.nu**2)/self.E\n",
    "    #\n",
    "formulas_A2.Jel = __\n",
    "\n",
    "A2.Jel()\n",
    "A2.jel"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def __(self):\n",
    "    self.total= self.jpl + self.jel\n",
    "formulas_A2.Jtotal = __\n",
    "\n",
    "A2.Jtotal()\n",
    "A2.jpl, A2.jel, A2.total    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "def __(self, *args):    \n",
    "    if len(args)==0: # last time\n",
    "        self.JR=np.asarray(self.JR)\n",
    "        return     \n",
    "    if (args[0])==None: # first time \n",
    "        self.JR= []\n",
    "        return\n",
    "    # next time\n",
    "    self.Apl(args[0])\n",
    "    self.Jpl()\n",
    "    self.Jel()\n",
    "    self.Jtotal()        \n",
    "    self.JR.append([self.delta, self.total])\n",
    "    #\n",
    "formulas_A2.makeJTotal = __\n",
    "A2.makeJTotal(None)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST\n",
    "A2.makeJTotal(None)# init\n",
    "for _ in [1.0,1.2,1.4,1.6]:\n",
    "    try:\n",
    "        A2.makeJTotal(_) #continue\n",
    "    except:\n",
    "        continue\n",
    "A2.makeJTotal()#end\n",
    "\n",
    "A2.JR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "pd.read_excel(pd.ExcelFile('1757-A52.xls'),'GFR')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "sht=pd.read_excel(pd.ExcelFile('1757-A52.xls'),'GFR')\n",
    "xlsm_ = np.transpose(np.asarray((sht.iloc[2:,2].values,sht.iloc[2:,3].values)))\n",
    "\n",
    "xlsm_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "A2.makeJTotal(None)\n",
    "_sheet =[]\n",
    "for _ in xlsm_:\n",
    "    if _[0]<A2.crack[:,0][0]:\n",
    "        continue\n",
    "    if _[0]>A2.crack[:,0][-1]:\n",
    "        break\n",
    "    try:\n",
    "        A2.makeJTotal(_[0])\n",
    "        _sheet.append([_[0],_[1]])\n",
    "        print _\n",
    "    except:\n",
    "        continue\n",
    "A2.makeJTotal()\n",
    "_sheet = np.asarray(_sheet)        \n",
    "A2.JR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 2)) # урезанный тренд\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 3)) # урезанный тренд\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 3)) # урезанный тренд\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 2)) # урезанный тренд\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "A2.JR"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 2)) # урезанный тренд\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "xy1=root1.calc(0.2)\n",
    "plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "#plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "root1=rootexline(1101,A2.JRtrend1)\n",
    "xy1=root1.calc(0.2)\n",
    "plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "#plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "#root1=rootexline(1101,A2.JRtrend1)\n",
    "xy1=root1.calc(0.2)\n",
    "plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "#plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(1101,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "#root1=rootexline(1101,A2.JRtrend1)\n",
    "#xy1=root1.calc(0.2)\n",
    "#plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(11010,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 2)) # урезанный тренд\n",
    "root1=rootexline(11010,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "#plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(11010,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "#root1=rootexline(1101,A2.JRtrend1)\n",
    "#xy1=root1.calc(0.2)\n",
    "#plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "#EXCLUSION LINE BUILDING:\n",
    "A2.JRtrend0= np.poly1d(np.polyfit(A2.JR[:,0], A2.JR[:,1], 2)) # исходный тренд\n",
    "\n",
    "class rootexline:\n",
    "    def __init__(self,k,trend):\n",
    "        self.k =k\n",
    "        self.trend=trend\n",
    "    def value(self,x1,x):\n",
    "        return self.k*(x-x1)\n",
    "    def calc(self,x1):\n",
    "        xx1=fsolve(lambda x:self.trend(x) - self.value(x1,x), x1)\n",
    "        return xx1[0],self.value(x1,xx1[0])\n",
    "#\n",
    "\n",
    "root0=rootexline(11010,A2.JRtrend0)\n",
    "roots0=root0.calc(0.15),root0.calc(1.5)\n",
    "\n",
    "JR0=A2.JR[(A2.JR[:,0] > roots0[0][0])]\n",
    "JR1=JR0[JR0[:,0]<roots0[1][0]]\n",
    "A2.JRtrend1= np.poly1d(np.polyfit(JR1[:,0], JR1[:,1], 2)) # урезанный тренд\n",
    "root1=rootexline(11010,A2.JRtrend1)\n",
    "roots1=root1.calc(0.2)\n",
    "\n",
    "print roots0\n",
    "print JR1\n",
    "print roots1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "JR0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "##TEST plt()\n",
    "plt.plot(_sheet[:,0], _sheet[:,1], 'r.')\n",
    "plt.plot(A2.JR[:,0], A2.JR[:,1], 'bp')\n",
    "plt.plot(JR1[:,0], A2.JRtrend1(JR1[:,0]), 'r--',)\n",
    "\n",
    "\n",
    "root0=rootexline(11010,A2.JRtrend0)\n",
    "xy1=root0.calc(0.15)\n",
    "plt.plot([0.15,xy1[0]], [0.0, xy1[1]], 'm-')\n",
    "xy2=root0.calc(1.5)\n",
    "plt.plot([1.5,xy2[0]], [0.0, xy2[1]], 'm-')\n",
    "\n",
    "root1=rootexline(11010,A2.JRtrend1)\n",
    "xy1=root1.calc(0.2)\n",
    "plt.plot([0.2,xy1[0]], [0.0, xy1[1]], 'g-')\n",
    "\n",
    "\n",
    "plt.grid()\n",
    "plt.rcParams[\"figure.figsize\"]=[14, 9.]\n",
    "\n",
    "plt.legend(('EXPERIMENTAL POINTS','SIMULATION POINTS','A2.JRtrend1(A2.JR[:,0])', \\\n",
    "            'EXCLUSION LINE LEFT','EXCLUSION LINE RIGHT','OFFSET LINE'))\n",
    "plt.show()\n",
    "xy1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Вводим в оборот метод чтения данных и строим интерполяторы\n",
    "from scipy.interpolate import interp1d\n",
    "\n",
    "def __(self, forcedat, cracklength):\n",
    "    self.forcedat = forcedat\n",
    "    self.cracklength = cracklength\n",
    "    \n",
    "    self.force = np.loadtxt(forcedat, dtype=np.float)\n",
    "  #  self.force[:,1]*=2.0\n",
    "  #  self.force[:,2]*=2.0\n",
    "    self.force_interp = interp1d(self.force[:,1],self.force[:,2], bounds_error=False)\n",
    "\n",
    "    #загружаем, редуцируем и модифицируем \"crack-length_calc1.dat\"\n",
    "    crk=[]\n",
    "    for xx in np.loadtxt(cracklength, dtype=np.float):\n",
    "        if xx[1]:\n",
    "            crk.append([xx[1], self._10(xx[1]+15.2)])\n",
    "    self.crack=np.asarray(crk)\n",
    "\n",
    "    #интерполяторы редуцированного массива crack\n",
    "    self.crack_interp = interp1d(self.crack[:,0],self.crack[:,1], bounds_error=False)\n",
    "    self.crack_cmode_interp = interp1d(self.crack[:,0], self.force[:,1][- len(self.crack): ], bounds_error=False)\n",
    "    #\n",
    "formulas_A2.read=__ #добавляем метод в Класс 'formulas_A2'\n",
    "A2.read(\"FORCE_CMOD_U820_V2.dat\",\"crack-length_U820_V2.dat\") # Юзаем метод для уже существующего Инстанса(экземпляра) 'A2'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "%lsmagic"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
